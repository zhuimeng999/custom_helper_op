/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

#include "tensorflow/core/framework/common_shape_fns.h"
#include "tensorflow/core/framework/op.h"
#include "tensorflow/core/framework/shape_inference.h"

namespace tensorflow {
namespace addons {

using shape_inference::DimensionHandle;
using shape_inference::InferenceContext;
using shape_inference::ShapeHandle;

namespace {

// TODO(qyu): Move this to core/framework/common_shape_fns.h
Status CostVolumeShapeFn(InferenceContext *c) {
  ShapeHandle images_shape;
  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 5, &images_shape));
  ShapeHandle homos_shape;
  TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 4, &homos_shape));
  auto batch_dim = c->Dim(images_shape, 0);
  auto height    = c->Dim(images_shape, 2);
  auto width     = c->Dim(images_shape, 3);
  auto channel_dim = c->Dim(images_shape, 4);
  auto depth_dim = c->Dim(homos_shape, 2);
  c->set_output(0, c->MakeShape({batch_dim, height, width, depth_dim, channel_dim}));
  c->set_output(1, c->MakeShape({batch_dim, height, width, depth_dim, 1}));
  return Status::OK();
}

static const char kCostVolumeDoc[] = R"doc(
Applies the given transform to each of the images.

Input `image` is a `Tensor` in NHWC format (where the axes are image in batch,
rows, columns, and channels. Input `transforms` is a num_images x 8 or 1 x 8
matrix, where each row corresponds to a 3 x 3 projective transformation matrix,
with the last entry assumed to be 1. If there is one row, the same
transformation will be applied to all images.

If one row of `transforms` is `[a0, a1, a2, b0, b1, b2, c0, c1]`, then it maps
the *output* point `(x, y)` to a transformed *input* point
`(x', y') = ((a0 x + a1 y + a2) / k, (b0 x + b1 y + b2) / k)`, where
`k = c0 x + c1 y + 1`. If the transformed point lays outside of the input
image, the output pixel is set to 0.

images: 4D `Tensor`, input image(s) in NHWC format.
transforms: 2D `Tensor`, projective transform(s) to apply to the image(s).

transformed_images: 4D `Tensor`, image(s) in NHWC format, generated by applying
the `transforms` to the `images`. Satisfies the description above.
)doc";

static const char kCostVolumeGradDoc[] = R"doc(
Applies the given transform to each of the images.

Input `image` is a `Tensor` in NHWC format (where the axes are image in batch,
rows, columns, and channels. Input `transforms` is a num_images x 8 or 1 x 8
matrix, where each row corresponds to a 3 x 3 projective transformation matrix,
with the last entry assumed to be 1. If there is one row, the same
transformation will be applied to all images.

If one row of `transforms` is `[a0, a1, a2, b0, b1, b2, c0, c1]`, then it maps
the *output* point `(x, y)` to a transformed *input* point
`(x', y') = ((a0 x + a1 y + a2) / k, (b0 x + b1 y + b2) / k)`, where
`k = c0 x + c1 y + 1`. If the transformed point lays outside of the input
image, the output pixel is set to 0.

images: 4D `Tensor`, input image(s) in NHWC format.
transforms: 2D `Tensor`, projective transform(s) to apply to the image(s).

grad: 4D `Tensor`, image(s) in NHWC format, generated by applying
the `transforms` to the `images`. Satisfies the description above.

image_grad: 4D `Tensor`, image(s) in NHWC format, generated by applying
the `transforms` to the `images`. Satisfies the description above.
)doc";

}  // namespace

// V2 op supports output_shape.
REGISTER_OP("CostVolume")
    .Input("images: dtype")
    .Input("transforms: dtype")
    .Attr("dtype: {float32}")
    .Attr("interpolation: string")
    .Output("transformed_images: dtype")
    .Output("transformed_mask: dtype")
    .SetShapeFn(CostVolumeShapeFn)
    .Doc(kCostVolumeDoc);

// V2 op supports output_shape.
REGISTER_OP("CostVolumeGrad")
    .Input("images: dtype")
    .Input("transforms: dtype")
    .Input("grad: dtype")
    .Attr("dtype: {float32}")
    .Attr("interpolation: string")
    .Output("image_grad: dtype")
    .SetShapeFn([](InferenceContext* c) {
      c->set_output(0, c->input(0));
      return Status::OK();
    })
    .Doc(kCostVolumeGradDoc);

}  // end namespace addons
}  // namespace tensorflow